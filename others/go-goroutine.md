## go语言中常见的并发模型

明确一个概念：并发并不是并行。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的，只有在真正的多核CPU上才可能真正的同时运行。并行更关注的是程序的运行层面，并行计算一般是简单的大量重复，例如GPU中对图像处理都有大量的并行计算。为了更好的编写并发的程序，go语言从设计之初就注重如何在编程语言层级上设计一个简单安全高效的抽象模型，让程序员专注与分解问题和组合方案。

在并发编程中，对共享资源的正确访问需要精确的控制，在目前的绝大多数语言中，都是通过加锁等线程同步的方案来解决这一困难问题。而go语言则是将共享的值通过channel进行传递。在任意给定的时刻，最好只有一个Goroutine能够拥有该资源。数据竞争是从设计层面就被杜绝了。go语言的编程哲学：不要通过共享内存来通信，而是应该通过通信来共享内存。

### 并发版本的hello world
```go
func main（）{
    done := make(chan int)
    go func(){
        fmt.Println("hello world!")
        done <- 1
    }()
    <- done
}
```

### 生产者和消费者模型

这是并发编程中最常见的例子，该模式主要是通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单的说，就是生产者生产一些数据，然后放到成果队列里面，同时消费者从成果队列里面取出这些数据。这样就让生产、消费变成了异步两个过程。当成果队列中没有数据的时候，消费者就进入饥饿等待中，当成果队列中的数据满时，生产者则面临因产品挤压而导致CPU被剥夺下岗的问题。

go语言中实现生产者和消费者模型如下：

```go
func Producer(factor int,out chan <- int){
    for i := 0; ;i++{
        out <- i*factor
    }
}
func Cunsumer(in <- chan int){
    for v:= range in{
        fmt.Println(v)
    }
}
func main(){
    ch := make(chan int, 64) //成果队列
    go Producer(3, ch)  //生产3的倍数
    go Producer(5, ch)  // 生产5的倍数
    go Consumer(ch)     // 消费 生成的队列
    time.Sleep(6 * time.Second)
}
```

### 发布订阅模型

发布订阅（publish-and-subscribe）模型通常被简写为pub/sub模型。在这个模型中，消息生产者成为发布者，而消息订阅者则成为订阅者，生产者和消费者的关系是M:N.在传统生产者和消费者模型中，是将消息发送到一个队列中，而发布订阅模型则是将消息发布给一个主题