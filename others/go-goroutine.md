## go语言中常见的并发模型

明确一个概念：并发并不是并行。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的，只有在真正的多核CPU上才可能真正的同时运行。并行更关注的是程序的运行层面，并行计算一般是简单的大量重复，例如GPU中对图像处理都有大量的并行计算。为了更好的编写并发的程序，go语言从设计之初就注重如何在编程语言层级上设计一个简单安全高效的抽象模型，让程序员专注与分解问题和组合方案。

在并发编程中，对共享资源的正确访问需要精确的控制，在目前的绝大多数语言中，都是通过加锁等线程同步的方案来解决这一困难问题。而go语言则是将共享的值通过channel进行传递。在任意给定的时刻，最好只有一个Goroutine能够拥有该资源。数据竞争是从设计层面就被杜绝了。go语言的编程哲学：不要通过共享内存来通信，而是应该通过通信来共享内存。

### 并发版本的hello world
```go
func main（）{
    done := make(chan int)
    go func(){
        fmt.Println("hello world!")
        done <- 1
    }()
    <- done
}
```